# -*- coding: utf-8 -*-
"""Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12MjdFfh1hJpT071OQLnb7q36PPoQNXQY

CODE WITH MOSH - PYTHON CHEATSHEET

SETTING UP VSCODE
"""

#View -> Command palette: Format document (AutoPep8)
#(does automatic indentation) -> go to Preferences -> settings -> FormatOnSave

#View -> Command palette: lint -> Select linter -> pylint
#(error msgs are easy to understand)

#extensions -> code runner

"""DATA TYPES"""

#int = 1, 2, 3
#float = 1.0, 2.2, 3.45
#str = "abc", 'crow'   #immutable
#list = [a,1,"hi"]     # mutable, ordered
#tup = ()              # immutable
#dict = {}             #unordered #mutable
#set = {}     #both dict and set have {} except that dict has key, value pairs and set has only value
#bool = True/False

"""NUMBERS (INT, FLOAT)"""

print(2+2) #gives int
print(2>1) #gives boolean

#TYPE CAST
#Changing float number 4.0 to int 4
number = 4.0
int(number) #4

print(7 / 4) #division - float
print(7 % 4) #modulo - int
#enclose these numbers within print () so both lines are printed. Else overriding occurs

2 + 10 * 10 + 2 #here * is taken first as per bodmas. Use brackets if + should be taken first

"""VARIABLES


"""

a = 20.1
type(a) #float

"""STRINGS"""

new_string = "hello"
# indexing  h  e  l  l  o
#           0  1  2  3  4
#           0 -4 -3 -2 -1

#slicing [start:stop:step] => [FIRST INDEX: LAST INDEX - 1: STEP]

#escape sequences \n - new line, \t - tab

#length
len('hey s') #5

#concatenation
myname = "nidhi"
print("hey " + myname)

#.format()
print("this is a {}".format("fox"))

#.format() function with indexing
print("this is a {1} brown {0} here".format("fox","quick"))

#also allocate variables
print("this is a {q} brown {f} here".format(f="fox",q="quick"))


#float formatting "{value:width.precision f}"
result = 1.23456789
print("the result is {r:1.3f}".format(r=result)) #3f for 3 decimals, width 1 is for spacing

#f strings (or) formatted string literals
name = "jose"
print("his name is {}".format(name)) #normal expression
print(f"his name is {name}") #f strings - injects variable into curly braces

"""METHODS ()"""

x = "Hello World"
x.upper() #all caps
x.lower() #all small letters

y = "hi this is a string"
y.split() #['hi', 'this', 'is', 'a', 'string']
y.split('i') #['h', ' th', 's ', 's a str', 'ng']

"""LISTS []"""

mylist = [1,2.3,"hey"]
len(mylist) #3
mylist[1:] #[2.3,"hey"]

twolist = [4,5]

#concatenation
newlist = mylist + twolist
newlist #[1,2.3,"hey,4,5]

#change element
newlist[0] = "ONE" #['ONE', 2.3, 'hey', 4, 5]

#ADD ELEMENTS TO END
newlist.append('six') #['ONE', 2.3, 'hey', 4, 5, 'six']
newlist

#REMOVE ELEMENTS FROM END OF LIST (POP BY DEFAULT REMOVES LAST ELEMENT)
newlist.pop() #removes last element from list, and also returns the value of removed element as output
newlist #['ONE', 2.3, 'hey', 4, 5]
poppedlist = newlist.pop() #5 is removed
poppedlist #5 is the output returned
newlist #['ONE', 2.3, 'hey', 4]

#REMOVE ELEMENTS FROM MIDDLE
newlist.pop(1) #2.3 is removed
newlist #['ONE', 'hey', 4]

#SORTING - DO NOT DO THESE STEPS CAUSE "NONE"
newl = [1,6,3,4,2,5]
newl.sort() #doesnt return anything but sorts!! SO YOU CANT PRINT THIS
newl #[1, 2, 3, 4, 5, 6]
sortedlist = newl.sort()
type(sortedlist) #NoneType
#NoneType corresponds to the type for the "None" object (special object in Py)
#this None indicated no value and is the return value of a method that returns no value

#SORTING - DO IT THIS WAY
newl2 = [1,4,7,3,9]
newl2.sort() #first sorts
newl2 #prints [1, 3, 4, 7, 9] sorted output
sorted = newl2
sorted #[1, 3, 4, 7, 9]

#REVERSE
newl2.reverse() #reverses elements
newl2 #[9, 7, 4, 3, 1]

#NESTEDLIST
nestedlist = [1,1,[1,2]] #list within a list is nested list
#if we want to return "2" from the nested list:
nestedlist[2][1] #returns 2
#[2][1] where index [2] is for returning [1,2], index [1] is for returning 2 (in this case [0] will be for 1)


#SORTED KEYWORD
#sorted(list1) is the same as list1.sort()

"""DICTIONARIES {}"""

#SYNTAX dic = {'key1':"value1", 'key2':"value2"}
#Call dic['key1] #o/p is "value1"
#for value, do not give '' for integer

dict1 = {'a':'123','b':[1,2,3],'c':{'c1':1234}}
#return [1,2,3]
dict1['b'] #[1,2,3]
dict1['b'][1] #returns 2

#return 1234
dict1['c']['c1'] #1234

#UPDATE ELEMENT
d = {'key1':['a','b','c']}

upd = d['key1'][1].upper()
upd #output will only be "C" as upper() returns single value

d['key1'][1] = upd #use this to update based on index
d  #{'key1': ['a', 'B', 'c']}

#ADD NEW ELEMENT TO DICT
d['key2'] = [1,2]
d                   #{'key1': ['a', 'B', 'c'], 'key2': [1, 2]}

#RETURN ALL KEYS
d.keys() #dict_keys(['key1', 'key2'])

#RETURN ALL VALUES
d.values() #dict_values([['a', 'B', 'c'], [1, 2]])

#RETURN ALL ITEMS (PAIRS)
d.items() #dict_items([('key1', ['a', 'B', 'c']), ('key2', [1, 2])])

"""TUPLES ()"""

#TUPLES ARE GENERALLY NOT USED BY PROGRAMMERS
#BUT WHEN WE DO ADVANCED PROGRAMMING, TO MAINTAIN "DATA INTEGRITY", THAT IS,
#TO MAKE SURE THAT THE ELEMENTS DONT GET ACCIDENTALLY CHANGED, WE GO FOR TUPLES

t = ('one',2,3,3)
len(t) #4
type(t) #tuple
t.count(3) #2
t.count('one') #1
t.index(3) #2 - returns the index of the first occurance
t.index('one') #0

#UPDATE ELEMENT - CANNOT CAUSE TUPLES ARE IMMUTABLE
t[0]='ONE' #TYPE ERROR - #UPDATE ELEMENT - CANNOT CAUSE TUPLES ARE IMMUTABLE

"""SETS"""

myset = set()
myset #set()

myset.add(1)
myset #{1}
myset.add(2)
myset #{1,2}

#ADDING DUPLICATES WONT REFLECT - CAUSE HAS TO BE UNIQUE SET OF ELEMENTS
myset.add(2)
myset #{1, 2}

#CASTING LIST AS SET
mylist = [4,4,4,1,1,1,1,2,2,3,3,3]
set(mylist) #{1, 2, 3, 4}
#it only orders in ascending to give output

"""BOOLEANS - TRUE/FALSE"""

#CASE SENSITIVE
#SHOULD BE True and not true
#type(false) #NameError
type(False) #bool

1>2 #False

"""I/O"""

# Commented out IPython magic to ensure Python compatibility.
# from typing import Text
# %%writefile myfile.Text #magically writes file
# Hi this is a text file
# line 1
# line 2
# line 3
# 
# #OPEN
# myfile = open('myfile.txt') #Errno 2] No such file or directory: 'myfile.txt' - if file not in jupyter directory or path not mentioned properly
# 
# #PRINTS O/P OF FILE
# myfile.read()
# #if you execute this again, you will get output '' because the cursor on
# #line 1 has reached end of text file. So we reset
# myfile.seek(0)
# 
# #READ EACH LINE
# myfile.readlines() #this will put each line separately
# 
# #LOCATION
# myfile = open("/Users/UserName/Folder/myfile.txt")
# 
# #CLOSE FILE
# myfile.close
# 
# #OPEN FILE AS DIFFERENT Name
# with open('myfile.txt', mode = 'r') as my_new_file:
#     contents = my_new_file.read()
# 
# contents #prints as new file name, the contents
# 
# #MODES - R, W, a
# mode = 'r' is read
# mode = 'w' is read
# mode = 'a' is append (can add new lines to end of existing file)
# mode = 'r+' is read and write
# mode = 'w+' is write and read (overwrite/create new file)
# 
# #READS FILE AND PRINTS
# with open('myfile.txt', mode = 'r') as my_new_file:
#     print(my_new_file.read())
# 
# #WRITING contents
# with open('myfile.txt', mode = 'w') as my_new_file:
#     my_new_file.write('writing one more line here!')
# 
# #IF FILE NAME DOESNT EXIST, IN MODE 'W', A NEW FILE IS CREATED IN PLACE
#

#TEST
#1
(((2**4)+(4))-(100/10))*10+0.25

#2
a = 3 +1.5+4
type(a)

#3 SQUARE ROOT
int(4**(1/2))


#4
s='hello'

#5
d = {'k1':[{'nest_key':['this is deep',['hello']]}]}

#Grab hello
d['k1'][0]['nest_key'][1][0]

"""COMPARISON OPERATORS != == > < >= <="""

2.0 == 2 #True
'2' == 2 #False

"""LOGICAL OPERATORS and or not"""

#and - both conditions should be True
#or - atleast one condition is True
#not - negates

not(1==1) #1==1 is True, O/P IS FALSE

"""IF, ELIF, ELSE LOOPS"""

#example1
hungry = "dh"

if hungry == "food":
  print("Feed me")
elif hungry == "drink":
  print("I'm thirsty")
elif hungry == "oats":
  print("Not tasty")
else:
  print("Don't")

"""FOR LOOPS"""

#Basic idea behind for loop:
#range = [,,,,,]
#SYNTAX
#for <object> in <range> #Here <object> will correspond to every element in []

mylist = [1,2,3,4,5]

for i in mylist:
  print(i) # 1 2 3 4 5
  print("hey") #hey hey hey hey hey

#CHECK EVEN OR ODD
mylist = [1,2,3,4,5]

for num in mylist:
  if num % 2 == 0:
    print("Even")
  else:
    print("Odd")

#RUNNING TOTAL
mylist = [1,2,3,4,5,6,7,8,9,10]
list_sum = 0

for i in mylist:
  list_sum = list_sum + i

print(list_sum)

#TUPLE IN LIST
tuplist = [(1,2),(3,4),(5,6),(7,8)]

for (a,b) in tuplist:
  print(a)
  print(b)

#ITERATE THROUGH DICTIONARY
d = {'a1':1, 'a2':2, 'a3':3}

for item in d:
  print (item) #here a1, a2, a3 is printed (keys)

print("")

for i in d.items():  #items() is a function
  print(i) #here the output is properly printed in (key,value) format

print("")

for key,value in d:
  print(value) #here the output clearly prints the value alone

print("")

for i in d.values(): #values() is a function
  print(i) #here the output prints only values

print("")

for i in d.keys(): #keys() is a function
  print(i)  #here the output prints only keys

#RANGE(start, stop, step)

for i in range(0,10,2): #0 to 9 iterated, step by 2
  print(i) #0 2 4 6 8

print("")

#CASTING AS LIST
list(range(0,10,2))

#printing index and letter
index_count = 0
word = 'abcdef'

for i in word:
  print("At index {} the letter is {}".format(index_count,i))
  index_count += 1

#replication of the above using enumerations

index_count = 0
word = 'abcdef'

for i in word:
  print(word[index_count]) #for variable word, we have index
  index_count += 1


#can also use enumerate() function - see under tuples heading

"""WHILE LOOP"""

x=2

while x < 5:
  print(f"The current value of x is {x}")
  x += 1 #there should always be a condition here, else infinite loop is formed
else:
  print(f"{x} is not less than 5")

"""BREAK, CONTINUE, PASS"""

#PASS
y = [1,2,3]

for i in y:
  #if there is nothing written here, then there will be an error
  #pass overrides the error
  pass

#CONTINUE
mystring = "nidhi"

for letter in mystring:
  if letter == 'd':
    continue #continue goes to the top of the closest enclosing loop
    #so in this case, d is skipped from executing and iterates the next letter
  print(letter)

#BREAK
mystring = "nidhi"

for letter in mystring:
  if letter == 'd':
    break #in this case, when there is an occurance of 'd', it exits the loop
    #no more iteration, so remaining letters wont be iterated
  print(letter)

"""EASY FUNCTIONS"""

#enumerate function (read this after studying looping)

word = 'abcdef'

#enumerate returns the index for the object with value
for item in enumerate(word):
  print(item)
#can also change item to index, letter AND print them separately

#ZIP FUNCTION
list1 = [1,2,3]
list2 = ['a','b','c']

zip(list1,list2) #<zip at 0x7d1e6405cec0> this is the location
list(zip(list1,list2)) #o/p: [(1, 'a'), (2, 'b'), (3, 'c')]

print("")

for item in zip(list1,list2):
  print(item) #output is a list of tuples

#MIN, MAX

list1 = [1,4,77,103]
print(min(list1))
print(max(list1))

#RANDOM, SHUFFLE
#from lib import func

from random import shuffle
shuffle(list1)
print(list1)

from random import randint
randint(1,100) #gives a random integer from range everytime

#ACCEPT USER INPUT
no = input("Enter a number:")
print("The number is:",no)
type(no) #string

int(no)

#hence we can write it as no = int(input("enter"))

"""LIST COMPREHENSION"""

#CONVENTIONAL WAY OF APPENDING CHARACTERS TO STRING
mystring = 'hello'
mylist = []

for letter in mystring:
  mylist.append(letter)

mylist

#INSTEAD, FOLLOW THIS
mystring = 'hello'
mylist = [letter for letter in mystring] #SYNTAX: <result_element> for <element> in <variable>
mylist

#TO USE A CONDITION (IF)
mylist = [i**2 for i in range(0,11) if i%2==0]
mylist

#ANOTHER EXAMPLE
celcius = [0,10,25,40,80,110]

fahrenheit = [(9/5)*i + 32 for i in celcius]
fahrenheit

#USING IF ELSE
results = [x if x%2==0 else 'ODD' for x in range(0,11)]
results

#NESTED LOOPS
mylist = []
for x in [2,4,6]:
  for y in [10,100,100]:
    mylist.append(x*y)

mylist

#LIST COMPREHENSION
mylist = [x*y for x in [2,4,6] for y in [10,100,1000]]
mylist

"""LOOPS AND LIST COMPREHENSION - TESTING ABILITY QUESTS"""

#PRINT WORDS THAT START WITH S
st = 'So Print only the words that start with s in this sentence'
st.split()

for i in st.split():
  if i[0]=='s' or i[0]=='S':
    print(i)

#NUMBERS IN RANGE 0-10 WHICH ARE EVEN
for i in range(0,11):
  if i%2 == 0:
    print(i)

#LIST COMPREHENSION FOR NUMBERS DIVISIBLE BY 3 IN RANGE 1 TO 50
mylist = [x for x in range(0,51) if x%3==0]
mylist

#FIND LENGTH OF WORD AND PRINT IF EVEN
st = 'Print every word in this sentence that has an even number of letters'
st.split()

for letter in st.split():
  letter.split(' ')

  if len(letter)%2==0:
    print(letter+" is even!")

#Divisible by 3 means print Fizz, by 5 means print Buzz, by both print FizzBuzz

for i in range(1,101):

  if i%3==0 and i%5==0:
    print("FizzBuzz")

  elif i%3==0:
    print("Fizz")

  elif i%5==0:
    print("Buzz")

  else:
    print(i)

"""METHODS AND FUNCTIONS"""

#KNOWN METHODS
#.append() - add element
#.pop() - remove last element
#intitalize a list and click tab, you'll find suggested methods. Enclose help(mylist.insert()) - this gives you an idea of what to include

#METHODS ARE INBUILT AND ALREADY GIVEN
#FUNCTIONS ARE DEFINED BY US

"""
FUNCTIONS SYNTAX:

def name_of_function(parameter):
<docstring> that explains the function

To call:
name_of_function(value_for_the_parameter)
"""
#PRINT VS RETURN
#return a+b  ----> here, return helps to save the value to a variable instead of just printing it
#print(a+b)

#example
def add(a,b):
  return a+b

result = add(2,3)
print(result) #5

#sample
def call_name(name):
  print(f'hello {name}')

call_name('nidhi') #if 'nidhi' argument is not passed, then error

# PRINT VS RETURN
def print_result(a,b):
  print(a+b)

def return_result(x,y):
  return x+y

print_result(10,20) #pass values
result = print_result(10,20) #passing function call with values into a variable

result
type(result) #type of result is NoneType - because print just prints, value is not stored as a variable

return_result(10,20) #pass values

result = return_result #passing function call with values into a variable
result
type(result) #type of result is function - because return doesnt just print, here value is  stored as a variable

#AVOIDING STRING VS INT MISTAKES

def sum(a,b):
  return a+b

sum(10,20) #30 cause + is arithmetic
sum('10','20') #1020 cause + is concatenation for strings passed as argument

#PASS KEYWORD USED TO NOT TO ANYTHING AND SKIP

def checklist(num_list):

  for i in num_list:
    if i%2==0:
      return True #there is a return statement here
    else:
      pass

  return false """we are putting the return outside the loop and NOT after the else condition because RETURN will break the loop
  and in this case, it will only check the first number in the list and return the value.
  If we use return outside the even_check loop, then any condition that is not an even will be passed on to get a return value "false"
"""
checklist([1,3])

#EMPLOYEE CHECK - COMPARING WHO WORKED MORE HOURS
#TUPLE UNPACKING

work_hours = [('dora',200),('tiger',3390),('tyla',880)]

def employee_check():
  current_max = 0
  employee_of_month = ' '

  for employee, hours in work_hours:
    if hours > current_max:
      current_max = hours
      employee_of_month = employee
    else:
      pass

  return(employee_of_month,current_max)

employee_check()

def myfunc():
    value = bool(input("Enter a boolean value: "))
    if value == 'True':
        return 'Hello'
    else:
        return 'Goodbye'

myfunc()

"""*ARGS, * *KWARGS"""

#*args returns a tuple
def myfunc(*args):
  return sum(args) * 2

myfunc(2,3)
myfunc(1,2,3,4,5,6,7)
#*args is used to denote that any no of arguments can be passed there (basically a tuple of arguments is passed)

#**kwargs returns a dictionary
def myfunc(**kwargs):
  print(kwargs)
  if 'fruit' in kwargs:
    print("The fruit is {}".format(kwargs['fruit']))
  else:
    print('No fruits here')

myfunc(fruit='apple',veggie='lettuce')

#Combining
def myfunc(*args,**kwargs):
  print(args)
  print(kwargs)
  print("I would like {} {}".format(args[0],kwargs['fruit']))

myfunc(10,20,30,veggie='lettuce',fruit='oranges')

def myfunc(input_string):
    result = ""
    for index, letter in enumerate(input_string):
        if index % 2 == 0:
            result += letter.upper()
        else:
            result += letter.lower()
    return result

myfunc('shreenidhi')

"""MAP FUNCTION"""

names = ['Ally','Sally','Eve']

def namelist(mystring):
  if len(mystring)%2==0:
    return 'EVEN'
  else:
    return mystring[0]

#transform this map function to a list: Just giving map(namelist,names) will only point to the location, not output
list(map(namelist,names)) #SYNTAX: map(functionname,input) #() for function needn't be included here

for item in map(namelist,names):
  print(item)

"""FILTER FUNCTION"""

nos = [1,2,3,4,5,6,7]

def check_even(num):
    return num%2==0


#filters based on condition. Isn't applied to all numbers in input. Map applies to all nos in input.
list(filter(check_even,nos))

"""LAMBDA FUNCTION"""

nos = [1,2,3,4,5,6,7]

# CONSIDER A FUNC THAT GIVES THE SQUARE
def square(num):
  return num**2

square(2) #4

#IN LAMBDA NOTATION, THIS IS WRITTEN AS
square = lambda num: num**2

square(4) #16

#ALSO WRITTEN AS
list(map(lambda num:num**2,nos))

#ANOTHER EG
names = ['Ally']

list(map(lambda i:i[0],names)) #['A']

#REVERSE STRING
list(map(lambda i:i[::-1],names)) #['yllA']

"""GLOBAL/LOCAL VARIABLES
(Priority - LEGB RULE)
L - Local variable within function
E - Enclosing function locals (func immediately that this func is within)
G - Global
B - Built-in
"""

name = 'shreenidhi' #global variable to function hello()

def greet():
  global name #bringing shreenidhi as the global value into the local space
  name = 'aadhitya' #enclosing variable to function hello()

  def hello():
    name = 'kalpana' #local variable to function hello()
    print("hello "+name)

  hello()

greet() #hello kalpana
print(name) #aadhitya #since "global" name is brought into the func, then any update is affected to x's value

"""PRACTICE PROBLEMS"""

def lesser_of_two_evens(a,b):
  if a>b:
    return b
  else:
    return a


lesser_of_two_evens(2,4)

'''Write a function takes a two-word string and returns True if both words begin with same letter
animal_crackers('Levelheaded Llama') --> True
animal_crackers('Crazy Kangaroo') --> False'''

def animal_crackers(string):
  word = string.split(" ")

  a = word[0]
  b = word[1]

  if a[0] == b[0]:
    return True
  else:
    return False

animal_crackers('Levelheaded Llama')
animal_crackers('Crazy Kangaroo')

def makes_twenty(a,b):
  if a+b==20:
    return True
  elif a==20 or b==20:
    return True
  else:
    return False

makes_twenty(11,10)

"""OBJECT ORIENTED PROGRAMMING

CLASS SYNTAX:

class NameOfClass():
    
    #paramX is a Class Object Variable (same as param1,param2 within init)
    paramX = 'XXX'
    
    #__init__ is instance of the actual object - special method
    #param1, param2 are attributes of the function (instead of global var)

    def __init__(self,param1,param2):
        self.param1 = param1
        self.param2 = param2

    def some_method(self):
        #perform some action
        print(self.param1)
"""

#EXAMPLE PROGRAM FOR __INIT__

class Dog():

  species = 'Mammals' #class object attribute

  def __init__(self,breed,color,spots):
    self.breed = breed #by convention LHS = RHS
    self.colorful = color #self.my_attribute = paramter
    self.spots = spots

my_dog = Dog(breed='Lab',color='White',spots = False) #here you call the parameter COLOR - RHS
type(my_dog)

my_dog.colorful #here you call the my_attribute COLORFUL - LHS

my_dog.species

#EXAMPLE PROGRAM FOR METHODS

class Dog():

  species = 'Mammals' #class object attribute

  def __init__(self,breed,color):
    self.breed = breed #by convention LHS = RHS
    self.colorful = color #self.my_attribute = paramter


  #method declaration
  def bark(self):
    print("WOOF! My breed is {}".format(self.breed)) #here you reference self.my_attribute

doggy = Dog('Lab','White')
doggy.bark() #calling a method includes (). For attributes we dont include brackets

#ANOTHER EXAMPLE
class Circle():

  pi = 3.14

  def __init__(self,radius):
    self.radius = radius
    self.area = radius*radius*Circle.pi #this can be called as self.pi (or) Circle.pi

  def circumference(self):
    return self.radius*self.pi*2

circum = Circle(2)
#circum.circumference() #12.56
circum.area

"""INHERITANCE
(Child class inherits methods and attributes from parent class)
"""

class Animal(): #main class - parent class

  def __init__(self): #parent class initialization
    print("Animal created")

  def who_am_i(self):
    print("I am an animal")

  def eat(self): #parent class method
    print("Animal is eating")

class Dog(): #child class

  def __init__(self): #child class initialization
    Animal.__init__(self) #creating an instance of the Animal class
    print("Dog created")

  def eat(self): #over-writing method from Animal class
    print("Animal is eating, which is a dog")

my_animal = Animal()
my_dog = Dog()

my_dog.eat()

"""POLYMORPHISM
(Different methods have same name)
"""

class Dog():

  def __init__(self,name):
    self.name = name

  def sound(self): #method is sound, which is similar to the Cat Class
    print(self.name+" Says Woof")

class Cat():

  def __init__(self,name):
    self.name = name

  def sound(self): #method is same as Dog class - this is an eg of Polymorphism
    print(self.name+" Says Meow")

ollie = Dog('Ollie')
olivia = Cat('Olivia')

olivia.name

"""ABSTRAT CLASSES
(Never expects to be instantiated, serves only as a base class)
"""

class Animal():

  def __init__(self,name):
    self.name = name

#THIS IS USED TO SHOW THAT SOUND() METHOD CAN BE USED BY CHILD CLASSES,
#BUT CANNOT BE CALLED DIRECTLY FROM THE PARENT CLASS. SO,
  def sound(self): #THIS IS AN ABSTRACT CLASS
    raise NotImplementedError("Subclass must implement this abstract method")


class Dog():

  def __init__(self,name):
    self.name = name

  def sound(self):
    print(self.name+" Says Woof")


class Cat():

  def __init__(self,name):
    self.name = name

  def sound(self):
    print(self.name+" Says Meow")

ani = Animal("Toto")
ani.sound()

"""OOPS - SPECIAL (MAGIC/DUNDER) METHODS

_ _str_ _ , _ _ len _ _ , _ _ del _ _ METHODS
(Printing something when Class() with __init__ is called)
"""

class Book():

  def __init__(self,title,author,pages): #when print is called, only address will be printed and no info
    self.title = title
    self.author = author
    self.pages = pages

  def __str__(self): #when print(b) is called
    return f"{self.title} by {self.author}"

  def __len__(self): #when len(b) is called
    return self.pages

  def __del__(self): #used to print the following when del(b) is called
    print("The object has been deleted")

b = Book('Python','Jose',200)
print(b) #can also be written as str(b)

len(b)

#del b
'''This line will delete the object from the computer's memory'''

"""MODULES

PyPI (Like NPM for Node.js)
===Repository for open-source third party python packages

pip install
"""

#COMMAND LINE
pip install <package_name>
python3

#VSCO IDE

#mymodule.py
def my_func():
  print("This is my module")

''' ------------------------------- '''
#myprog.py
from mymodule import my_func
myfunc()

#terminal
cd <directory>
python3 myprog.py

"""PACKAGES

'''
Packages will have Subpackages.
When we create a new package, we make sure that each Package and Subpackages will:
(1) Have a __init__.py file #This file can be created by us and kept blank cause it helps python understand that this file exists and so the directory is indentified as a Package/Sub-package.
"""



"""_ _ name _ _ and _ _ main _ _

(These two are allocated immediately by python when a program is run)
"""

#Lets consider 2 programs - one.py and two.py

#one.py

def func():
  print("Func() in two.py")

print("Line one")

if __name__ == "__main__":
  print("One.py is being executed")
else:
  print("One.py is being imported")



#two.py
import one

def func():
  print("Func() in two.py")

print("Line two")

if __name__ == "__main__":
  print("two.py is being executed")
else:
  print("two.py is being imported")

#OUTPUTS

#running one.py
Line one
One.py is being executed

#running two.py
Line one
One.py is being imported
Line two
Func() in one.py
two.py is being executed


'''Explanation:
Basically here __name__ == "__main__" is default and is executed everytime
we run a python program. But here, we are attempting to modify it.
Checking the conditions, we get the above outputs.
"If" is executed when the program is directly executed.
"Else" is executed when the other module called is imported.
'''

"""Errors & Exception Handling

(TRY, EXCEPT, FINALLY)



try:
  #WANT TO ATTEMPT THIS CODE
  #MAY HAVE AN ERROR


except:
  #EXECUTES WHEN ERROR IN TRY


finally:
  #EXECUTES REGARDLESS OF ERROR
"""

#SYNTAX
def add(x,y):
  return x+y

num1 = 10

try: #check if there is error in the following, if not - executes
  num2 = (input())
  add(num1,num2)

except: #executes if error in try
  print("Some new error has occured")

#MULTIPLE EXCEPTS
#TypeError, OSError are a real errors (already known) - can be declared
while True:
    try:
      f = open('testfile','r')
      f.write("Write a test line")
    except TypeError: #input type is wrong and wont match
      print("There was a type error")
    except OSError: #something like - 'r' permissions given, but 'w' is called
      print("There was an OS Error")
    else:
      print("Thank you") #since While is mentioned, also executes when "try" is executed
    finally: #always runs when there is no error in the above
      print("I always run")

"""PYTHON DECORATORS"""

#Call Function into a Variable
def hello(): #define a function
  print("Hello!")

greet = hello() #assign the function to a variable greet

hello #will return the type

del hello #delete the function

greet #call the variable, you'll get the function's output even after its deleted